# gin_mini

Gin_mini is a lightweight HTTP web framework written in Go (Golang). This is a tiny demo project to show how to build web applications using Go.

## Architecture

Here files are organized in the following way:

├─context
|  └─context.go
├─ginmini
|  └─ginmini.go
├─logger
|  └─logger.go
├─recovery
|  └─recovery.go
├─router
|  └─router.go
├─trie
|  └─trie.go
├─go.mod
└─main.go

And will provide the following features:

- Routing: Mapping of HTTP requests to corresponding handlers, support for dynamic routing. (for example: /user/:id)
- Templates: Rendering of templates, support for multiple template engines. 
- Utilities: Cookies, headers or so.
- Plugins: Support for custom middleware for each HTTP method (or selected ones only).
- ...

## Basics

### http.Handler interface

In Go, if you look like an interface, then you are that interface.

```golang
package http

type Handler interface {
    ServeHTTP(w ResponseWriter, r *Request)
}

func ListenAndServe(address string, h Handler) error
```

`Handler` is an interface that requires the implementation of the method `ServeHTTP()`, which means that as long as any interface instance that implements the `ServerHTTP()`  is passed in, all HTTP requests will be handled by that instance.

So `Engine` defined in [/ginmini/ginmini.go](ginmini/ginmini.go) is an implementation of the `Handler` interface.

### Context

For web services, it's just a matter of constructing a responding `http.ResponseWriter` based on the request `*http.Request`. But the two objects provide too detailed an interface granularity, for example, if we want to construct a complete response, we need to consider the message header and the body, and the Header contains the status code, content type and other information that needs to be set in almost every request. Therefore, without effective encapsulation, users of the framework will need to write a lot of repetitive, cumbersome code and will be error-prone. The ability to efficiently construct HTTP responses for common scenarios is a point that a good framework must consider.

Encapsulating the `*http.Request` and `http.ResponseWriter` methods is also necessary to support additional functionality. For example, context will be the place where dynamic matching parameters will be stored at. Another example is that the framework needs to support plugin middleware, where will the information generated by the middleware be placed? Context is generated when each request is created and will be destroyed at the end of the request, and all the information strongly related to the current request should be carried by the context. Thus, the `Context` struct is designed to keep the complexity internal, while simplifying the interface externally.
